//! Linux Hello - Configuration GUI pour KDE/Wayland
//!
//! Interface graphique pour:
//! - Enregistrement de visage avec preview en direct
//! - Configuration des paramÃ¨tres d'authentification
//! - Gestion des visages enregistrÃ©s

use iced::widget::{Button, Column, Container, ProgressBar, Row, Text};
use iced::{executor, Application, Command, Element, Length};
use std::time::Instant;

mod animation_tests;
mod animation_ticker;
mod button_builder;
mod button_state;
mod config;
mod dbus_client;
mod gui_integration_tests;
mod performance_tests;
mod preview;
mod render_cache;
mod streaming;
mod ui;

use animation_ticker::AnimationTicker;
use button_builder::styled_button;
use button_state::{ButtonState, ButtonStates};
use iced::futures::stream::{self, Stream};
use iced::futures::StreamExt;
use render_cache::{BoundingBoxCache, FrameCache};
use std::time::Duration;
use streaming::CaptureFrame;
use ui::Screen;

pub fn main() -> iced::Result {
    LinuxHelloConfig::run(Default::default())
}

/// Application principale
struct LinuxHelloConfig {
    current_screen: Screen,
    current_frame: Option<CaptureFrame>,
    frame_count: u32,
    total_frames: u32,
    capture_active: bool,
    preview_state: preview::PreviewState,

    // Animation state
    animated_progress: f32,         // Animated version of progress_percent()
    progress_animation_target: f32, // Target progress value
    last_animation_update: Instant, // Track timing for smooth animation
    animation_preview_opacity: f32, // Fade-in effect for preview area (0.0-1.0)

    // Button states for transitions
    button_states: ButtonStates,

    // Rendering optimization caches
    frame_cache: FrameCache,      // Avoid redundant frame calculations
    bbox_cache: BoundingBoxCache, // Lazy bounding box drawing

    // Animation ticker
    animation_ticker: AnimationTicker, // Generates animation ticks
}

#[derive(Debug, Clone)]
enum Message {
    // Navigation
    GoToHome,
    GoToEnroll,
    GoToSettings,
    GoToManageFaces,

    // Enrollment
    StartCapture,
    StopCapture,
    FrameCaptured(Vec<u8>),

    // D-Bus Streaming
    CaptureProgressReceived(String), // JSON event from daemon
    CaptureCompleted(u32),           // user_id
    CaptureError(String),            // error message

    // Settings
    SettingChanged(String, String),

    // Animations
    AnimationTick, // Update animations every frame

    // Button interactions for visual effects
    ButtonHovered(String),   // Button ID hovered
    ButtonUnhovered(String), // Button ID unhovered
    ButtonPressed(String),   // Button ID pressed
    ButtonReleased(String),  // Button ID released

    // General
    WindowClosed,
}

impl Application for LinuxHelloConfig {
    type Message = Message;
    type Executor = executor::Default;
    type Theme = iced::Theme;
    type Flags = ();

    fn new(_flags: ()) -> (Self, Command<Message>) {
        let ticker = AnimationTicker::new();
        ticker.start(); // Start animation ticker immediately

        (
            Self {
                current_screen: Screen::Home,
                current_frame: None,
                frame_count: 0,
                total_frames: 0,
                capture_active: false,
                preview_state: preview::PreviewState::new(),
                animated_progress: 0.0,
                progress_animation_target: 0.0,
                last_animation_update: Instant::now(),
                animation_preview_opacity: 1.0,
                button_states: ButtonStates::new(),
                frame_cache: FrameCache::new(),
                bbox_cache: BoundingBoxCache::new(),
                animation_ticker: ticker,
            },
            Command::none(),
        )
    }

    fn title(&self) -> String {
        "Linux Hello - Configuration".to_string()
    }

    fn update(&mut self, message: Message) -> Command<Message> {
        match message {
            Message::GoToHome => {
                self.current_screen = Screen::Home;
                self.capture_active = false;
            }
            Message::GoToEnroll => {
                self.current_screen = Screen::Enrollment;
            }
            Message::GoToSettings => {
                self.current_screen = Screen::Settings;
            }
            Message::GoToManageFaces => {
                self.current_screen = Screen::ManageFaces;
            }
            Message::StartCapture => {
                self.capture_active = true;
                self.frame_count = 0;
                self.total_frames = 30;
                self.animation_preview_opacity = 0.5; // Fade-in start
                                                      // TODO: Lancer la capture via D-Bus
            }
            Message::StopCapture => {
                self.capture_active = false;
                self.animation_preview_opacity = 1.0; // Reset opacity
                                                      // TODO: ArrÃªter la capture
            }
            Message::FrameCaptured(_data) => {
                // TODO: Afficher la frame
            }
            Message::CaptureProgressReceived(json) => {
                // Parser le JSON et mettre Ã  jour current_frame
                if let Ok(frame) = serde_json::from_str::<CaptureFrame>(&json) {
                    self.frame_count = frame.frame_number + 1;
                    self.total_frames = frame.total_frames;

                    // Update animation target with new progress
                    self.progress_animation_target =
                        (frame.frame_number as f32 + 1.0) / frame.total_frames as f32;

                    self.current_frame = Some(frame.clone());

                    // Invalidate rendering caches when new frame arrives
                    self.frame_cache.invalidate();

                    // Update bbox cache - check if face is detected
                    let face_detected = frame.face_detected;
                    let confidence = frame.quality_score;
                    self.bbox_cache.update(face_detected, confidence);

                    self.preview_state.update_frame(frame);

                    // Fade-in preview
                    if self.animation_preview_opacity < 1.0 {
                        self.animation_preview_opacity =
                            (self.animation_preview_opacity + 0.15).min(1.0);
                    }
                }
            }
            Message::CaptureCompleted(user_id) => {
                tracing::info!("Capture complÃ©tÃ©e pour user_id={}", user_id);
                self.capture_active = false;
                self.animated_progress = 1.0;
            }
            Message::CaptureError(err) => {
                tracing::error!("Erreur capture: {}", err);
                self.capture_active = false;
            }
            Message::SettingChanged(_key, _value) => {
                // TODO: Sauvegarder le paramÃ¨tre
            }
            Message::AnimationTick => {
                // Process animation updates from the ticker
                // Apply smooth interpolation to animated_progress
                const ANIMATION_DURATION: f32 = 300.0; // ms

                let now = Instant::now();
                let elapsed = now.duration_since(self.last_animation_update).as_secs_f32() * 1000.0;

                // Interpolate progress towards target
                if (self.animated_progress - self.progress_animation_target).abs() > 0.001 {
                    let delta = self.progress_animation_target - self.animated_progress;
                    let speed = (elapsed / ANIMATION_DURATION).min(1.0);
                    self.animated_progress += delta * speed * 0.1;
                    self.animated_progress = self.animated_progress.max(0.0).min(1.0);
                }

                self.last_animation_update = now;
            }
            Message::ButtonHovered(button_id) => {
                // Update button state to Hover
                match button_id.as_str() {
                    "start_capture" => self.button_states.start_capture_btn = ButtonState::Hover,
                    "stop_capture" => self.button_states.stop_capture_btn = ButtonState::Hover,
                    "home" => self.button_states.home_btn = ButtonState::Hover,
                    "enroll" => self.button_states.enroll_btn = ButtonState::Hover,
                    "settings" => self.button_states.settings_btn = ButtonState::Hover,
                    "manage" => self.button_states.manage_btn = ButtonState::Hover,
                    _ => {}
                }
            }
            Message::ButtonUnhovered(button_id) => {
                // Return button state to Normal
                match button_id.as_str() {
                    "start_capture" => self.button_states.start_capture_btn = ButtonState::Normal,
                    "stop_capture" => self.button_states.stop_capture_btn = ButtonState::Normal,
                    "home" => self.button_states.home_btn = ButtonState::Normal,
                    "enroll" => self.button_states.enroll_btn = ButtonState::Normal,
                    "settings" => self.button_states.settings_btn = ButtonState::Normal,
                    "manage" => self.button_states.manage_btn = ButtonState::Normal,
                    _ => {}
                }
            }
            Message::ButtonPressed(button_id) => {
                // Set button to Pressed state
                match button_id.as_str() {
                    "start_capture" => self.button_states.start_capture_btn = ButtonState::Pressed,
                    "stop_capture" => self.button_states.stop_capture_btn = ButtonState::Pressed,
                    "home" => self.button_states.home_btn = ButtonState::Pressed,
                    "enroll" => self.button_states.enroll_btn = ButtonState::Pressed,
                    "settings" => self.button_states.settings_btn = ButtonState::Pressed,
                    "manage" => self.button_states.manage_btn = ButtonState::Pressed,
                    _ => {}
                }
            }
            Message::ButtonReleased(button_id) => {
                // Reset button state after press
                match button_id.as_str() {
                    "start_capture" => self.button_states.start_capture_btn = ButtonState::Normal,
                    "stop_capture" => self.button_states.stop_capture_btn = ButtonState::Normal,
                    "home" => self.button_states.home_btn = ButtonState::Normal,
                    "enroll" => self.button_states.enroll_btn = ButtonState::Normal,
                    "settings" => self.button_states.settings_btn = ButtonState::Normal,
                    "manage" => self.button_states.manage_btn = ButtonState::Normal,
                    _ => {}
                }
            }
            Message::WindowClosed => {
                // TODO: Cleanup
            }
        }
        Command::none()
    }

    fn view(&self) -> Element<Message> {
        let content = match self.current_screen {
            Screen::Home => self.view_home(),
            Screen::Enrollment => self.view_enrollment(),
            Screen::Settings => self.view_settings(),
            Screen::ManageFaces => self.view_manage_faces(),
        };

        Container::new(content)
            .width(Length::Fill)
            .height(Length::Fill)
            .center_x()
            .center_y()
            .into()
    }

    fn subscription(&self) -> iced::Subscription<Message> {
        // Subscribe to animation ticks if capture is active
        if self.capture_active {
            return animation_subscription();
        }
        iced::Subscription::none()
    }
}

impl LinuxHelloConfig {
    /// Process any pending animation ticks from the background ticker
    fn _process_pending_animation_ticks(&mut self) {
        // Poll the ticker for any pending ticks (non-blocking)
        while let Some(_tick) = self.animation_ticker.try_tick() {
            // Smooth animation towards target
            const ANIMATION_DURATION: f32 = 300.0; // ms

            let now = Instant::now();
            let elapsed = now.duration_since(self.last_animation_update).as_secs_f32() * 1000.0;

            // Interpolate progress towards target
            if (self.animated_progress - self.progress_animation_target).abs() > 0.001 {
                let delta = self.progress_animation_target - self.animated_progress;
                let speed = (elapsed / ANIMATION_DURATION).min(1.0);
                self.animated_progress += delta * speed * 0.1;
                self.animated_progress = self.animated_progress.max(0.0).min(1.0);
            }

            self.last_animation_update = now;
        }
    }
    fn view_home(&self) -> Element<Message> {
        use iced::widget::{Column, Text, Row, Space};

        let title = Text::new("ðŸŽ¯ Linux Hello - Authentification Faciale")
            .size(28);

        let subtitle = Text::new("Configuration et gestion d'authentification")
            .size(16);

        let enroll_btn = Button::new(Text::new("ðŸ“· Enregistrer un Visage"))
            .on_press(Message::GoToEnroll)
            .padding(15)
            .width(Length::Fill);

        let settings_btn = Button::new(Text::new("âš™ï¸ ParamÃ¨tres"))
            .on_press(Message::GoToSettings)
            .padding(15)
            .width(Length::Fill);

        let manage_btn = Button::new(Text::new("ðŸ‘¥ GÃ©rer les Visages"))
            .on_press(Message::GoToManageFaces)
            .padding(15)
            .width(Length::Fill);

        let button_row = Row::new()
            .push(enroll_btn)
            .push(Space::with_width(Length::Fixed(10.0)))
            .push(settings_btn)
            .push(Space::with_width(Length::Fixed(10.0)))
            .push(manage_btn)
            .spacing(10)
            .width(Length::Fill);

        let content = Column::new()
            .push(title)
            .push(Space::with_height(Length::Fixed(10.0)))
            .push(subtitle)
            .push(Space::with_height(Length::Fixed(40.0)))
            .push(Text::new("Bienvenue dans Linux Hello").size(20))
            .push(Space::with_height(Length::Fixed(20.0)))
            .push(Text::new(
                "Cette interface permet de:\n\
                â€¢ Enregistrer votre visage pour l'authentification\n\
                â€¢ Configurer les paramÃ¨tres d'authentification\n\
                â€¢ GÃ©rer vos visages enregistrÃ©s\n\
                â€¢ Activer/dÃ©sactiver l'authentification faciale"
            ).size(14))
            .push(Space::with_height(Length::Fixed(40.0)))
            .push(button_row)
            .spacing(10)
            .padding(40)
            .width(Length::Fill);

        Container::new(content)
            .width(Length::Fill)
            .height(Length::Fill)
            .into()
    }

    fn view_enrollment(&self) -> Element<'_, Message> {
        use iced::widget::{Button, Column, ProgressBar};

        let progress = self.animated_progress; // Use animated progress instead
        let progress_text = self.preview_state.progress_text();
        let detection_text = self.preview_state.detection_status();
        let animation_opacity = self.animation_preview_opacity; // Capture value

        let preview_display = if self.preview_state.current_frame.is_some() {
            // Afficher: "Frame en cours de capture" avec fade-in
            Container::new(
                Column::new()
                    .push(Text::new("ðŸ“¹ Preview en direct"))
                    .push(Text::new(format!(
                        "RÃ©solution: {}Ã—{}",
                        self.preview_state.width, self.preview_state.height
                    )))
                    .push(Text::new(detection_text))
                    .spacing(10),
            )
            .width(Length::Fill)
            .padding(20)
            .style(move |_theme: &iced::Theme| {
                use iced::widget::container;

                // Dynamic opacity based on animation state
                let bg_color = iced::Color::from_rgb(0.1, 0.1, 0.1);
                let rgba = iced::Color {
                    r: bg_color.r,
                    g: bg_color.g,
                    b: bg_color.b,
                    a: animation_opacity, // Apply fade animation
                };

                container::Appearance {
                    background: Some(rgba.into()),
                    ..Default::default()
                }
            })
        } else {
            Container::new(Text::new("En attente de capture...").size(16))
                .width(Length::Fill)
                .padding(40)
                .center_x()
        };

        let progress_bar = ProgressBar::new(0.0..=1.0, progress);

        let enrollment_content = Column::new()
            .push(Text::new("Enregistrement de Visage").size(24))
            .push(preview_display)
            .push(
                Column::new()
                    .push(progress_bar)
                    .push(Text::new(format!("Progression: {}", progress_text)))
                    .spacing(5)
                    .width(Length::Fill)
                    .padding(20),
            )
            .push(
                Row::new()
                    .push(
                        Button::new(Text::new("â–¶ DÃ©marrer"))
                            .on_press(Message::StartCapture)
                            .padding(10),
                    )
                    .push(
                        Button::new(Text::new("â¹ ArrÃªter"))
                            .on_press(Message::StopCapture)
                            .padding(10),
                    )
                    .push(
                        Button::new(Text::new("ðŸ  Accueil"))
                            .on_press(Message::GoToHome)
                            .padding(10),
                    )
                    .spacing(10)
                    .width(Length::Fill)
                    .padding(20),
            )
            .width(Length::Fill)
            .spacing(10)
            .padding(20);

        Container::new(enrollment_content)
            .width(Length::Fill)
            .height(Length::Fill)
            .into()
    }

    fn view_settings(&self) -> Element<'_, Message> {
        use iced::widget::{Column, Button, Row, Space};

        let back_btn = Button::new(Text::new("â† Retour"))
            .on_press(Message::GoToHome)
            .padding(10);

        let title = Text::new("âš™ï¸ ParamÃ¨tres").size(24);

        let section1 = Text::new("Authentification Faciale").size(16);
        let setting1 = Text::new("âœ“ Authentification faciale activÃ©e").size(13);
        let setting2 = Text::new("Timeout: 3000ms").size(13);
        let setting3 = Text::new("Seuil de qualitÃ©: 0.7").size(13);

        let section2 = Text::new("Capture").size(16);
        let setting4 = Text::new("Nombre de frames: 30").size(13);
        let setting5 = Text::new("RÃ©solution: 640Ã—480").size(13);

        let section3 = Text::new("SystÃ¨me").size(16);
        let setting6 = Text::new("âœ“ Mode dÃ©bogage").size(13);
        let setting7 = Text::new("Enregistrement des logs: ActivÃ©").size(13);

        let save_btn = Button::new(Text::new("ðŸ’¾ Sauvegarder"))
            .on_press(Message::SettingChanged("all".to_string(), "save".to_string()))
            .padding(12)
            .width(Length::Fill);

        let content = Column::new()
            .push(back_btn)
            .push(Space::with_height(Length::Fixed(20.0)))
            .push(title)
            .push(Space::with_height(Length::Fixed(30.0)))
            .push(section1)
            .push(setting1)
            .push(setting2)
            .push(setting3)
            .push(Space::with_height(Length::Fixed(20.0)))
            .push(section2)
            .push(setting4)
            .push(setting5)
            .push(Space::with_height(Length::Fixed(20.0)))
            .push(section3)
            .push(setting6)
            .push(setting7)
            .push(Space::with_height(Length::Fixed(40.0)))
            .push(save_btn)
            .spacing(10)
            .padding(40)
            .width(Length::Fill);

        Container::new(content)
            .width(Length::Fill)
            .height(Length::Fill)
            .into()
    }

    fn view_manage_faces(&self) -> Element<'_, Message> {
        use iced::widget::{Column, Button, Row, Space};

        let back_btn = Button::new(Text::new("â† Retour"))
            .on_press(Message::GoToHome)
            .padding(10);

        let title = Text::new("ðŸ‘¥ GÃ©rer les Visages").size(24);

        let face1_title = Text::new("Visage 1 - Principal").size(14);
        let face1_info = Text::new("EnregistrÃ© le: 2026-01-08").size(11);
        let face1_del = Button::new(Text::new("ðŸ—‘ Supprimer")).padding(8);
        let face1_row = Row::new()
            .push(Column::new().push(face1_title).push(face1_info).width(Length::Fill))
            .push(face1_del)
            .spacing(10);

        let face2_title = Text::new("Visage 2 - Sauvegarde").size(14);
        let face2_info = Text::new("EnregistrÃ© le: 2026-01-05").size(11);
        let face2_del = Button::new(Text::new("ðŸ—‘ Supprimer")).padding(8);
        let face2_row = Row::new()
            .push(Column::new().push(face2_title).push(face2_info).width(Length::Fill))
            .push(face2_del)
            .spacing(10);

        let add_btn = Button::new(Text::new("âž• Ajouter un nouveau visage"))
            .on_press(Message::GoToEnroll)
            .padding(12)
            .width(Length::Fill);

        let content = Column::new()
            .push(back_btn)
            .push(Space::with_height(Length::Fixed(20.0)))
            .push(title)
            .push(Space::with_height(Length::Fixed(30.0)))
            .push(Text::new("Visages enregistrÃ©s").size(16))
            .push(Space::with_height(Length::Fixed(15.0)))
            .push(face1_row)
            .push(Space::with_height(Length::Fixed(15.0)))
            .push(face2_row)
            .push(Space::with_height(Length::Fixed(40.0)))
            .push(add_btn)
            .spacing(10)
            .padding(40)
            .width(Length::Fill);

        Container::new(content)
            .width(Length::Fill)
            .height(Length::Fill)
            .into()
    }
}

/// Create an animation subscription that emits AnimationTick messages at ~60fps
fn animation_subscription() -> iced::Subscription<Message> {
    // Create a subscription that emits AnimationTick at ~60fps when capture is active
    animation_ticker_recipe()
}

/// Recipe for animation ticks
fn animation_ticker_recipe() -> iced::Subscription<Message> {
    use iced::subscription;

    subscription::run_with_id("animation_ticker", animation_stream_generator())
}

/// Generate an animation tick stream
fn animation_stream_generator() -> impl iced::futures::Stream<Item = Message> + Send + 'static {
    use std::time::Duration;

    // Create a stream that emits ticks at 60fps
    // Use async_stream's stream! macro with tokio::time::interval
    async_stream::stream! {
        let mut interval = tokio::time::interval(Duration::from_millis(16));
        loop {
            interval.tick().await;
            yield Message::AnimationTick;
        }
    }
}
